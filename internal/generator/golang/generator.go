package golang

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"platosl.org/cmd/platosl/internal/generator"
)

// Generator generates Go structs from CUE
type Generator struct{}

// NewGenerator creates a new Go generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Name returns the generator name
func (g *Generator) Name() string {
	return "go"
}

// Generate generates Go code
func (g *Generator) Generate(ctx *generator.Context) ([]byte, error) {
	var buf bytes.Buffer

	// Package declaration
	pkgName := ctx.GetStringOption("package", "types")
	fmt.Fprintf(&buf, "// Generated by PlatoSL\n")
	fmt.Fprintf(&buf, "// DO NOT EDIT - This file is auto-generated\n\n")
	fmt.Fprintf(&buf, "package %s\n\n", pkgName)

	// Extract definitions
	defs, err := extractDefinitions(ctx.Value)
	if err != nil {
		return nil, fmt.Errorf("failed to extract definitions: %w", err)
	}

	// Sort definitions for consistent output
	var defNames []string
	for name := range defs {
		defNames = append(defNames, name)
	}
	sort.Strings(defNames)

	// Generate structs
	for _, name := range defNames {
		val := defs[name]
		goName := toGoName(name)

		// Generate struct
		structCode, err := generateStruct(goName, val)
		if err != nil {
			return nil, fmt.Errorf("failed to generate struct for %s: %w", name, err)
		}
		buf.WriteString(structCode)
		buf.WriteString("\n")
	}

	return buf.Bytes(), nil
}

// Validate validates the generator context
func (g *Generator) Validate(ctx *generator.Context) error {
	if err := ctx.Value.Err(); err != nil {
		return fmt.Errorf("invalid CUE value: %w", err)
	}
	return nil
}

// extractDefinitions extracts all definitions from a CUE value
func extractDefinitions(val cue.Value) (map[string]cue.Value, error) {
	defs := make(map[string]cue.Value)

	iter, err := val.Fields(cue.Definitions(true))
	if err != nil {
		return nil, err
	}

	for iter.Next() {
		label := iter.Selector().String()
		if strings.HasPrefix(label, "#") {
			defs[label] = iter.Value()
		}
	}

	return defs, nil
}

// generateStruct generates a Go struct
func generateStruct(name string, val cue.Value) (string, error) {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "type %s struct {\n", name)

	// Iterate fields
	iter, err := val.Fields(cue.Optional(true))
	if err != nil {
		return "", err
	}

	for iter.Next() {
		label := iter.Selector().String()
		fieldVal := iter.Value()
		optional := iter.IsOptional()

		// Skip definitions
		if strings.HasPrefix(label, "#") {
			continue
		}

		// Map type
		goType := mapToGoType(fieldVal)

		// Optional fields are pointers
		if optional {
			goType = "*" + goType
		}

		// Generate field with JSON tag
		fieldName := toGoFieldName(label)
		jsonTag := label
		if optional {
			jsonTag += ",omitempty"
		}

		fmt.Fprintf(&buf, "\t%s %s `json:\"%s\"`\n", fieldName, goType, jsonTag)
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// mapToGoType maps a CUE type to Go
func mapToGoType(val cue.Value) string {
	kind := val.IncompleteKind()

	switch {
	case kind&cue.StringKind != 0:
		return "string"
	case kind&cue.IntKind != 0:
		return "int"
	case kind&cue.FloatKind != 0:
		return "float64"
	case kind&cue.NumberKind != 0:
		return "float64"
	case kind&cue.BoolKind != 0:
		return "bool"
	case kind&cue.ListKind != 0:
		// Try to get element type
		elemType := getListElementType(val)
		return "[]" + elemType
	case kind&cue.StructKind != 0:
		// Check if it references a definition
		if ref := getDefinitionReference(val); ref != "" {
			return toGoName(ref)
		}
		return "interface{}"
	default:
		return "interface{}"
	}
}

// getListElementType gets the element type of a list
func getListElementType(val cue.Value) string {
	// Try to get the first element or list constraint
	iter, err := val.List()
	if err == nil && iter.Next() {
		return mapToGoType(iter.Value())
	}
	return "interface{}"
}

// getDefinitionReference checks if a value references a definition
func getDefinitionReference(val cue.Value) string {
	// This is a simplified implementation
	return ""
}

// toGoName converts a CUE definition name to Go type name
func toGoName(name string) string {
	// Remove leading # and ensure PascalCase
	name = strings.TrimPrefix(name, "#")

	// Basic conversion to PascalCase
	if len(name) > 0 {
		name = strings.ToUpper(name[:1]) + name[1:]
	}

	return name
}

// toGoFieldName converts a field name to Go field name
func toGoFieldName(name string) string {
	// Convert to PascalCase for exported fields
	parts := strings.Split(name, "_")
	for i, part := range parts {
		if len(part) > 0 {
			parts[i] = strings.ToUpper(part[:1]) + part[1:]
		}
	}
	return strings.Join(parts, "")
}

func init() {
	// Register the generator
	generator.Register(NewGenerator())
}
