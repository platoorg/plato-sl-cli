package typescript

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"github.com/platoorg/plato-sl-cli/internal/generator"
)

// Generator generates TypeScript types and Zod schemas from CUE
type Generator struct{}

// NewGenerator creates a new TypeScript generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Name returns the generator name
func (g *Generator) Name() string {
	return "typescript"
}

// Generate generates TypeScript code
func (g *Generator) Generate(ctx *generator.Context) ([]byte, error) {
	var buf bytes.Buffer

	// Header
	buf.WriteString("// Generated by PlatoSL\n")
	buf.WriteString("// DO NOT EDIT - This file is auto-generated\n\n")

	// Extract definitions
	defs, err := extractDefinitions(ctx.Value)
	if err != nil {
		return nil, fmt.Errorf("failed to extract definitions: %w", err)
	}

	// Sort definitions for consistent output
	var defNames []string
	for name := range defs {
		defNames = append(defNames, name)
	}
	sort.Strings(defNames)

	// Generate TypeScript interfaces
	for _, name := range defNames {
		val := defs[name]
		tsName := toTypescriptName(name)

		// Generate interface
		iface, err := generateInterface(tsName, val)
		if err != nil {
			return nil, fmt.Errorf("failed to generate interface for %s: %w", name, err)
		}
		buf.WriteString(iface)
		buf.WriteString("\n")
	}

	return buf.Bytes(), nil
}

// Validate validates the generator context
func (g *Generator) Validate(ctx *generator.Context) error {
	if err := ctx.Value.Err(); err != nil {
		return fmt.Errorf("invalid CUE value: %w", err)
	}
	return nil
}

// extractDefinitions extracts all definitions from a CUE value
func extractDefinitions(val cue.Value) (map[string]cue.Value, error) {
	defs := make(map[string]cue.Value)

	iter, err := val.Fields(cue.Definitions(true))
	if err != nil {
		return nil, err
	}

	for iter.Next() {
		label := iter.Selector().String()
		if strings.HasPrefix(label, "#") {
			defs[label] = iter.Value()
		}
	}

	return defs, nil
}

// generateInterface generates a TypeScript interface
func generateInterface(name string, val cue.Value) (string, error) {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "export interface %s {\n", name)

	// Iterate fields
	iter, err := val.Fields(cue.Optional(true))
	if err != nil {
		return "", err
	}

	for iter.Next() {
		label := iter.Selector().String()
		fieldVal := iter.Value()
		optional := iter.IsOptional()

		// Skip definitions
		if strings.HasPrefix(label, "#") {
			continue
		}

		// Clean field name (remove CUE syntax markers like ! and ?)
		cleanLabel := cleanFieldName(label)

		// Map type
		tsType := mapToTypescriptType(fieldVal)

		// Generate field
		if optional {
			fmt.Fprintf(&buf, "  %s?: %s;\n", cleanLabel, tsType)
		} else {
			fmt.Fprintf(&buf, "  %s: %s;\n", cleanLabel, tsType)
		}
	}

	buf.WriteString("}\n")

	return buf.String(), nil
}

// generateZodSchema generates a Zod schema
func generateZodSchema(name string, val cue.Value) (string, error) {
	var buf bytes.Buffer

	schemaName := name + "Schema"
	fmt.Fprintf(&buf, "export const %s = z.object({\n", schemaName)

	// Iterate fields
	iter, err := val.Fields(cue.Optional(true))
	if err != nil {
		return "", err
	}

	for iter.Next() {
		label := iter.Selector().String()
		fieldVal := iter.Value()
		optional := iter.IsOptional()

		// Skip definitions
		if strings.HasPrefix(label, "#") {
			continue
		}

		// Clean field name (remove CUE syntax markers like ! and ?)
		cleanLabel := cleanFieldName(label)

		// Map to Zod type
		zodType := mapToZodType(fieldVal)

		// Add optional modifier
		if optional {
			zodType = zodType + ".optional()"
		}

		fmt.Fprintf(&buf, "  %s: %s,\n", cleanLabel, zodType)
	}

	buf.WriteString("});\n")

	return buf.String(), nil
}

// mapToTypescriptType maps a CUE type to TypeScript
func mapToTypescriptType(val cue.Value) string {
	kind := val.IncompleteKind()

	switch {
	case kind&cue.StringKind != 0:
		return "string"
	case kind&cue.IntKind != 0:
		return "number"
	case kind&cue.FloatKind != 0:
		return "number"
	case kind&cue.NumberKind != 0:
		return "number"
	case kind&cue.BoolKind != 0:
		return "boolean"
	case kind&cue.ListKind != 0:
		// Try to get element type
		elemType := getListElementType(val)
		return elemType + "[]"
	case kind&cue.StructKind != 0:
		// Check if it references a definition
		if ref := getDefinitionReference(val); ref != "" {
			return toTypescriptName(ref)
		}
		return "object"
	default:
		return "unknown"
	}
}

// mapToZodType maps a CUE type to Zod
func mapToZodType(val cue.Value) string {
	kind := val.IncompleteKind()

	switch {
	case kind&cue.StringKind != 0:
		// Check for string constraints (regex, etc.)
		return "z.string()"
	case kind&cue.IntKind != 0:
		return "z.number().int()"
	case kind&cue.FloatKind != 0:
		return "z.number()"
	case kind&cue.NumberKind != 0:
		return "z.number()"
	case kind&cue.BoolKind != 0:
		return "z.boolean()"
	case kind&cue.ListKind != 0:
		elemType := getListElementZodType(val)
		return fmt.Sprintf("z.array(%s)", elemType)
	case kind&cue.StructKind != 0:
		// Check if it references a definition
		if ref := getDefinitionReference(val); ref != "" {
			return toTypescriptName(ref) + "Schema"
		}
		return "z.object({})"
	default:
		return "z.unknown()"
	}
}

// getListElementType gets the element type of a list
func getListElementType(val cue.Value) string {
	// Try to get the first element or list constraint
	iter, err := val.List()
	if err == nil && iter.Next() {
		return mapToTypescriptType(iter.Value())
	}
	return "unknown"
}

// getListElementZodType gets the Zod element type of a list
func getListElementZodType(val cue.Value) string {
	// Try to get the first element or list constraint
	iter, err := val.List()
	if err == nil && iter.Next() {
		return mapToZodType(iter.Value())
	}
	return "z.unknown()"
}

// getDefinitionReference checks if a value references a definition
func getDefinitionReference(val cue.Value) string {
	// This is a simplified implementation
	// In a real implementation, you'd walk the value to find definition references
	return ""
}

// toTypescriptName converts a CUE definition name to TypeScript
func toTypescriptName(name string) string {
	// Remove leading # and ensure PascalCase
	name = strings.TrimPrefix(name, "#")

	// Basic conversion
	if len(name) > 0 {
		name = strings.ToUpper(name[:1]) + name[1:]
	}

	return name
}

// cleanFieldName removes CUE syntax markers from field names
func cleanFieldName(name string) string {
	// Remove trailing ! (required marker) and ? (optional marker)
	name = strings.TrimSuffix(name, "!")
	name = strings.TrimSuffix(name, "?")
	return name
}

func init() {
	// Register the generator
	generator.Register(NewGenerator())
}
