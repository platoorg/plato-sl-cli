package elixir

import (
	"bytes"
	"fmt"
	"sort"
	"strings"

	"cuelang.org/go/cue"
	"github.com/platoorg/plato-sl-cli/internal/generator"
)

// Generator generates Elixir typespecs from CUE
type Generator struct{}

// NewGenerator creates a new Elixir generator
func NewGenerator() *Generator {
	return &Generator{}
}

// Name returns the generator name
func (g *Generator) Name() string {
	return "elixir"
}

// Generate generates Elixir code
func (g *Generator) Generate(ctx *generator.Context) ([]byte, error) {
	var buf bytes.Buffer

	// Module declaration
	moduleName := ctx.GetStringOption("module", "MyApp.Types")
	fmt.Fprintf(&buf, "# Generated by PlatoSL\n")
	fmt.Fprintf(&buf, "# DO NOT EDIT - This file is auto-generated\n\n")
	fmt.Fprintf(&buf, "defmodule %s do\n", moduleName)
	fmt.Fprintf(&buf, "  @moduledoc \"\"\"\n")
	fmt.Fprintf(&buf, "  Type definitions generated from CUE schemas.\n")
	fmt.Fprintf(&buf, "  \"\"\"\n\n")

	// Extract definitions
	defs, err := extractDefinitions(ctx.Value)
	if err != nil {
		return nil, fmt.Errorf("failed to extract definitions: %w", err)
	}

	// Sort definitions for consistent output
	var defNames []string
	for name := range defs {
		defNames = append(defNames, name)
	}
	sort.Strings(defNames)

	// Generate typespecs
	for _, name := range defNames {
		val := defs[name]
		elixirName := toElixirName(name)

		// Generate typespec
		typespecCode, err := generateTypespec(elixirName, val)
		if err != nil {
			return nil, fmt.Errorf("failed to generate typespec for %s: %w", name, err)
		}
		buf.WriteString(typespecCode)
		buf.WriteString("\n")
	}

	buf.WriteString("end\n")

	return buf.Bytes(), nil
}

// Validate validates the generator context
func (g *Generator) Validate(ctx *generator.Context) error {
	if err := ctx.Value.Err(); err != nil {
		return fmt.Errorf("invalid CUE value: %w", err)
	}
	return nil
}

// extractDefinitions extracts all definitions from a CUE value
func extractDefinitions(val cue.Value) (map[string]cue.Value, error) {
	defs := make(map[string]cue.Value)

	iter, err := val.Fields(cue.Definitions(true))
	if err != nil {
		return nil, err
	}

	for iter.Next() {
		label := iter.Selector().String()
		if strings.HasPrefix(label, "#") {
			defs[label] = iter.Value()
		}
	}

	return defs, nil
}

// generateTypespec generates an Elixir typespec
func generateTypespec(name string, val cue.Value) (string, error) {
	var buf bytes.Buffer

	// Start type definition
	fmt.Fprintf(&buf, "  @type %s() :: %%__MODULE__.%s{\n", toSnakeCase(name), name)

	// Iterate fields
	iter, err := val.Fields(cue.Optional(true))
	if err != nil {
		return "", err
	}

	var fields []string
	for iter.Next() {
		label := iter.Selector().String()
		fieldVal := iter.Value()
		optional := iter.IsOptional()

		// Skip definitions
		if strings.HasPrefix(label, "#") {
			continue
		}

		// Map type
		elixirType := mapToElixirType(fieldVal)

		// Optional fields can be nil
		if optional {
			elixirType = elixirType + " | nil"
		}

		fields = append(fields, fmt.Sprintf("    %s: %s", label, elixirType))
	}

	buf.WriteString(strings.Join(fields, ",\n"))
	buf.WriteString("\n  }\n\n")

	// Also generate a struct definition
	fmt.Fprintf(&buf, "  defstruct [")
	var fieldNames []string
	iter2, _ := val.Fields(cue.Optional(true))
	for iter2.Next() {
		label := iter2.Selector().String()
		if !strings.HasPrefix(label, "#") {
			fieldNames = append(fieldNames, ":"+label)
		}
	}
	buf.WriteString(strings.Join(fieldNames, ", "))
	buf.WriteString("]\n")

	return buf.String(), nil
}

// mapToElixirType maps a CUE type to Elixir
func mapToElixirType(val cue.Value) string {
	kind := val.IncompleteKind()

	switch {
	case kind&cue.StringKind != 0:
		return "String.t()"
	case kind&cue.IntKind != 0:
		return "integer()"
	case kind&cue.FloatKind != 0:
		return "float()"
	case kind&cue.NumberKind != 0:
		return "number()"
	case kind&cue.BoolKind != 0:
		return "boolean()"
	case kind&cue.ListKind != 0:
		// Try to get element type
		elemType := getListElementType(val)
		return "list(" + elemType + ")"
	case kind&cue.StructKind != 0:
		// Check if it references a definition
		if ref := getDefinitionReference(val); ref != "" {
			return toSnakeCase(toElixirName(ref)) + "()"
		}
		return "map()"
	default:
		return "any()"
	}
}

// getListElementType gets the element type of a list
func getListElementType(val cue.Value) string {
	// Try to get the first element or list constraint
	iter, err := val.List()
	if err == nil && iter.Next() {
		return mapToElixirType(iter.Value())
	}
	return "any()"
}

// getDefinitionReference checks if a value references a definition
func getDefinitionReference(val cue.Value) string {
	// This is a simplified implementation
	return ""
}

// toElixirName converts a CUE definition name to Elixir module name
func toElixirName(name string) string {
	// Remove leading # and ensure PascalCase
	name = strings.TrimPrefix(name, "#")

	// Basic conversion to PascalCase
	if len(name) > 0 {
		name = strings.ToUpper(name[:1]) + name[1:]
	}

	return name
}

// toSnakeCase converts a name to snake_case
func toSnakeCase(name string) string {
	var result []rune
	for i, r := range name {
		if i > 0 && 'A' <= r && r <= 'Z' {
			result = append(result, '_')
		}
		result = append(result, r)
	}
	return strings.ToLower(string(result))
}

func init() {
	// Register the generator
	generator.Register(NewGenerator())
}
